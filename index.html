<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Web Design Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        #canvas {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #f0f2f5;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.08) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.08) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: auto;
            /* New properties for zoom */
            transform-origin: top left;
            transition: transform 0.1s ease-out;
        }
        .draggable {
            position: absolute;
            cursor: move;
            user-select: none;
            border: 2px solid transparent;
            transition: border-color 0.2s, border-radius 0.3s;
        }
        .draggable.selected {
            border-color: #3b82f6;
        }
        .draggable[contenteditable="true"] {
            background-color: rgba(59, 130, 246, 0.1);
            cursor: text;
        }
        .resizer {
            width: 12px;
            height: 12px;
            background: #3b82f6;
            position: absolute;
            right: -6px;
            bottom: -6px;
            cursor: se-resize;
            border-radius: 50%;
            border: 2px solid white;
            display: none;
        }
        .draggable.selected .resizer {
            display: block;
        }
        .snap-line {
            position: absolute;
            background-color: #ef4444;
            display: none;
            z-index: 9999;
        }
        #snap-line-v { width: 1px; height: 100%; top: 0; }
        #snap-line-h { height: 1px; width: 100%; left: 0; }
        #selection-box {
            position: absolute;
            border: 1px dashed #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
            pointer-events: none;
            z-index: 10001;
            display: none;
        }
        #layers-list li {
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid transparent;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #layers-list li:hover {
            background-color: #f3f4f6;
        }
        #layers-list li.selected {
            background-color: #dbeafe;
            border-color: #3b82f6;
            font-weight: 600;
        }
        #layers-list li.dragging {
            opacity: 0.5;
        }
        .image-caption {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px;
            font-size: 14px;
            text-align: center;
            cursor: text;
            user-select: text;
        }
        .screen-box {
            background-color: #ffffff;
            border: 2px solid #cbd5e1;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            resize: both;
            overflow: hidden;
            position: relative;
        }
        .screen-box::before {
            content: attr(data-screen-name);
            position: absolute;
            top: -24px;
            left: 0;
            font-size: 12px;
            font-weight: 600;
            color: #4b5563;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex">

    <!-- Sidebar -->
    <aside class="w-64 bg-white shadow-lg p-4 flex flex-col space-y-4 overflow-y-auto">
        <div>
            <h1 class="text-xl font-bold text-gray-800 mb-4">Tools</h1>
            <div class="space-y-3">
                <button id="add-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Button</button>
                <button id="add-img" class="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Image</button>
                <button id="add-title" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Title</button>
                <button id="add-text" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Text</button>
                <button id="add-box" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Box</button>
            </div>
        </div>
        
        <div class="pt-4 border-t">
            <h2 class="text-lg font-bold text-gray-700 mb-4">Screens</h2>
            <div class="space-y-3">
                 <select id="screen-preset" class="w-full p-2 border rounded-md text-sm bg-white">
                    <option value="375x667">XS: Mobile Portrait (375x667)</option>
                    <option value="667x375">S: Mobile Landscape (667x375)</option>
                    <option value="768x1024">M: Tablet (768x1024)</option>
                    <option value="1280x800">L: Laptop (1280x800)</option>
                    <option value="1440x900">XL: Desktop (1440x900)</option>
                    <option value="1920x1080">XXL: Wide Desktop (1920x1080)</option>
                </select>
                <button id="add-screen" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md text-sm">Add Screen</button>
            </div>
        </div>

        <div class="pt-4 border-t">
            <h2 class="text-lg font-bold text-gray-700 mb-4">Align & Distribute</h2>
            <div class="grid grid-cols-2 gap-3">
                <button id="align-v" class="w-full bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-2 rounded-lg shadow-md text-sm">Align Vertical</button>
                <button id="align-h" class="w-full bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-2 rounded-lg shadow-md text-sm">Align Horizontal</button>
                <button id="distribute-h" class="col-span-2 w-full bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md text-sm">Distribute Horizontal</button>
                <button id="distribute-v" class="col-span-2 w-full bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md text-sm">Distribute Vertical</button>
                <button id="group-selection" class="col-span-2 w-full bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md text-sm">Group</button>
            </div>
        </div>

        <div class="pt-4 border-t flex-grow flex flex-col min-h-0">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold text-gray-700">Layers</h2>
                <div class="space-x-2">
                    <button id="layer-up" title="Layer Up" class="px-2 py-1 bg-gray-200 rounded hover:bg-gray-300">â–²</button>
                    <button id="layer-down" title="Layer Down" class="px-2 py-1 bg-gray-200 rounded hover:bg-gray-300">â–¼</button>
                    <button id="detect-collisions" title="Show Collisions Only" class="px-2 py-1 bg-gray-200 rounded hover:bg-gray-300">ðŸ’¥</button>
                </div>
            </div>
            <ul id="layers-list" class="space-y-2 overflow-y-auto flex-grow"></ul>
        </div>

        <div class="mt-auto pt-4 border-t space-y-3">
             <button id="save-canvas" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md">
                Save Progress
            </button>
             <button id="clear-canvas" class="w-full bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md">
                Clear Canvas
            </button>
        </div>
    </aside>

    <!-- Main Canvas -->
    <main class="flex-1 h-screen relative">
        <div id="canvas"></div>
        <div id="selection-box"></div>
        <div id="snap-line-v" class="snap-line"></div>
        <div id="snap-line-h" class="snap-line"></div>
        <!-- Zoom Controls -->
        <div id="zoom-controls" class="absolute bottom-4 right-4 bg-white shadow-lg rounded-lg p-1 flex items-center space-x-1 z-50">
            <button id="zoom-out" class="w-8 h-8 rounded hover:bg-gray-200 flex items-center justify-center font-bold text-lg">-</button>
            <span id="zoom-level" class="text-sm font-medium w-14 text-center">100%</span>
            <button id="zoom-in" class="w-8 h-8 rounded hover:bg-gray-200 flex items-center justify-center font-bold text-lg">+</button>
        </div>
    </main>

    <!-- Properties Panel -->
    <aside id="properties-panel" class="w-64 bg-white shadow-lg p-4 hidden"></aside>

    <script>
        // --- DOM SELECTORS ---
        const canvas = document.getElementById('canvas');
        const main = canvas.parentElement;
        const selectionBox = document.getElementById('selection-box');
        const snapLineV = document.getElementById('snap-line-v');
        const snapLineH = document.getElementById('snap-line-h');
        const layersList = document.getElementById('layers-list');
        const propertiesPanel = document.getElementById('properties-panel');
        const addBtn = document.getElementById('add-btn');
        const addImg = document.getElementById('add-img');
        const addTitle = document.getElementById('add-title');
        const addText = document.getElementById('add-text');
        const addBox = document.getElementById('add-box');
        const clearCanvasBtn = document.getElementById('clear-canvas');
        const saveCanvasBtn = document.getElementById('save-canvas');
        const distributeHBtn = document.getElementById('distribute-h');
        const distributeVBtn = document.getElementById('distribute-v');
        const alignVBtn = document.getElementById('align-v');
        const alignHBtn = document.getElementById('align-h');
        const groupSelectionBtn = document.getElementById('group-selection');
        const layerUpBtn = document.getElementById('layer-up');
        const layerDownBtn = document.getElementById('layer-down');
        const detectCollisionsBtn = document.getElementById('detect-collisions');
        const addScreenBtn = document.getElementById('add-screen');
        const screenPresetSelect = document.getElementById('screen-preset');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const zoomLevelDisplay = document.getElementById('zoom-level');

        // --- APP STATE ---
        let selectedElements = [];
        let elementCounter = 0;
        let isCollisionViewActive = false;
        let zoomLevel = 1.0;

        // --- ZOOM LOGIC ---
        function setZoom(newZoom) {
            zoomLevel = Math.max(0.2, Math.min(newZoom, 3.0)); // Clamp zoom between 20% and 300%
            canvas.style.transform = `scale(${zoomLevel})`;
            zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
        }
        zoomInBtn.addEventListener('click', () => setZoom(zoomLevel + 0.1));
        zoomOutBtn.addEventListener('click', () => setZoom(zoomLevel - 0.1));
        main.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const zoomIntensity = 0.05;
                const direction = e.deltaY < 0 ? 1 : -1;
                setZoom(zoomLevel + direction * zoomIntensity);
            }
        }, { passive: false });


        // --- PROPERTIES PANEL ---
        function updatePropertiesPanel() {
            propertiesPanel.innerHTML = '';
            if (selectedElements.length !== 1) {
                propertiesPanel.classList.add('hidden');
                return;
            }
            const el = selectedElements[0];
            propertiesPanel.classList.remove('hidden');
            propertiesPanel.innerHTML = `<h2 class="text-lg font-bold text-gray-700 mb-4">Properties</h2>`;
            if (el.dataset.type === 'Image') {
                const shapeContainer = document.createElement('div');
                shapeContainer.className = 'flex items-center space-x-4 mb-4';
                shapeContainer.innerHTML = `<label class="text-sm font-medium text-gray-700">Shape:</label>`;
                const isCircular = el.classList.contains('rounded-full');
                const rectBtn = document.createElement('button');
                rectBtn.className = `p-2 rounded-md border-2 ${!isCircular ? 'border-blue-500' : 'border-gray-300'}`;
                rectBtn.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="1"></rect></svg>`;
                rectBtn.onclick = () => { el.classList.remove('rounded-full'); updatePropertiesPanel(); };
                const circleBtn = document.createElement('button');
                circleBtn.className = `p-2 rounded-md border-2 ${isCircular ? 'border-blue-500' : 'border-gray-300'}`;
                circleBtn.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>`;
                circleBtn.onclick = () => { el.classList.add('rounded-full'); updatePropertiesPanel(); };
                shapeContainer.appendChild(rectBtn);
                shapeContainer.appendChild(circleBtn);
                propertiesPanel.appendChild(shapeContainer);
                const captionContainer = document.createElement('div');
                captionContainer.className = 'flex items-center justify-between';
                captionContainer.innerHTML = `<label for="caption-toggle" class="text-sm font-medium text-gray-700">Caption</label>`;
                const captionToggle = document.createElement('input');
                captionToggle.type = 'checkbox';
                captionToggle.id = 'caption-toggle';
                const captionEl = el.querySelector('.image-caption');
                captionToggle.checked = captionEl.style.display !== 'none';
                captionToggle.onchange = () => {
                    captionEl.style.display = captionToggle.checked ? 'block' : 'none';
                };
                captionContainer.appendChild(captionToggle);
                propertiesPanel.appendChild(captionContainer);
            }
        }

        // --- LAYERS PANEL (REBUILT FOR STABILITY) ---
        function renderLayersPanel() {
            layersList.innerHTML = '';
            const allElements = [...canvas.children].filter(el => el.classList.contains('draggable'));

            let elementsToShow = allElements;
            if (isCollisionViewActive && selectedElements.length === 1) {
                const selectedEl = selectedElements[0];
                const rect1 = selectedEl.getBoundingClientRect();
                const colliding = allElements.filter(otherEl => {
                    if (otherEl === selectedEl) return false;
                    const rect2 = otherEl.getBoundingClientRect();
                    return !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);
                });
                elementsToShow = [selectedEl, ...colliding];
            }

            const sortedAll = [...allElements].sort((a, b) => (parseInt(a.style.zIndex) || 0) - (parseInt(b.style.zIndex) || 0));

            elementsToShow
                .sort((a, b) => (parseInt(b.style.zIndex) || 0) - (parseInt(a.style.zIndex) || 0))
                .reverse()
                .forEach(el => {
                    const li = document.createElement('li');
                    const layerIndex = sortedAll.indexOf(el);

                    if (!el.dataset.name || (el.dataset.name.endsWith('...') && el.isContentEditable === false)) {
                        if (el.dataset.type === 'Text' || el.dataset.type === 'Title' || el.dataset.type === 'Button') {
                            const text = el.textContent.trim();
                            el.dataset.name = text.substring(0, 15) + (text.length > 15 ? '...' : '');
                        } else {
                            el.dataset.name = el.dataset.screenName || el.dataset.type;
                        }
                    }

                    li.textContent = `Layer ${layerIndex}: ${el.dataset.name}`;
                    li.dataset.id = el.id;
                    li.draggable = true;

                    if (selectedElements.includes(el)) {
                        li.classList.add('selected');
                    }

                    li.addEventListener('click', () => selectElement(el, false));
                    li.addEventListener('dragstart', () => li.classList.add('dragging'));
                    li.addEventListener('dragend', () => li.classList.remove('dragging'));
                    layersList.appendChild(li);
                });
        }
        layersList.addEventListener('dragover', e => { e.preventDefault(); const draggingItem = layersList.querySelector('.dragging'); const afterElement = getDragAfterElement(layersList, e.clientY); if (afterElement == null) layersList.appendChild(draggingItem); else layersList.insertBefore(draggingItem, afterElement); });
        layersList.addEventListener('drop', () => updateZIndexFromLayers());
        function getDragAfterElement(container, y) { const draggableElements = [...container.querySelectorAll('li:not(.dragging)')]; return draggableElements.reduce((closest, child) => { const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2; if (offset < 0 && offset > closest.offset) return { offset: offset, element: child }; else return closest; }, { offset: Number.NEGATIVE_INFINITY }).element; }
        function updateZIndexFromLayers() { const layerItems = [...layersList.querySelectorAll('li')]; const totalLayers = layerItems.length; layerItems.forEach((li, index) => { const el = document.getElementById(li.dataset.id); if (el) el.style.zIndex = totalLayers - index; }); renderLayersPanel(); }
        layerUpBtn.addEventListener('click', () => moveLayer(1));
        layerDownBtn.addEventListener('click', () => moveLayer(-1));
        function moveLayer(direction) { if (selectedElements.length !== 1) return; const selectedId = selectedElements[0].id; const layerItems = [...layersList.querySelectorAll('li')]; const currentIndex = layerItems.findIndex(li => li.dataset.id === selectedId); if (direction === 1 && currentIndex > 0) { layersList.insertBefore(layerItems[currentIndex], layerItems[currentIndex - 1]); } else if (direction === -1 && currentIndex < layerItems.length - 1) { layersList.insertBefore(layerItems[currentIndex + 1], layerItems[currentIndex]); } updateZIndexFromLayers(); }

        // --- ELEMENT CREATION ---
        function createElement(tag, classes, content, type, customStyles = {}, dataset = {}) {
            const el = document.createElement(tag);
            el.id = `el-${elementCounter++}`;
            el.className = `draggable ${classes}`;
            if(content) el.innerHTML = content;
            Object.assign(el.style, {
                left: customStyles.left || `${(main.scrollLeft / zoomLevel) + 50}px`,
                top: customStyles.top || `${(main.scrollTop / zoomLevel) + 50}px`,
                width: customStyles.width || 'auto',
                height: customStyles.height || 'auto',
                zIndex: customStyles.zIndex || canvas.children.length + 1
            });
            Object.assign(el.dataset, { type, ...dataset });
            el.dataset.name = dataset.name || (type === 'Image' || type === 'Box' ? type : content.substring(0, 15) + (content.length > 15 ? '...' : ''));
            setupElement(el);
            canvas.appendChild(el);
            renderLayersPanel();
            return el;
        }
        addBtn.addEventListener('click', () => selectElement(createElement('button', 'bg-blue-500 text-white py-2 px-4 rounded-lg shadow-md', 'Click me', 'Button'), false));
        addTitle.addEventListener('click', () => selectElement(createElement('h1', 'text-4xl font-bold text-gray-800 p-2', 'Title', 'Title'), false));
        addText.addEventListener('click', () => selectElement(createElement('p', 'text-gray-700 p-2 w-64', 'Example paragraph.', 'Text'), false));
        addBox.addEventListener('click', () => selectElement(createElement('div', 'bg-white border-2 border-gray-400 rounded-lg', '', 'Box', {width: '200px', height: '200px'}), false));
        addImg.addEventListener('click', () => {
            const el = createElement('div', 'p-0 overflow-hidden bg-gray-300 rounded-lg shadow-md relative', '', 'Image', {width: '200px', height: '150px'});
            const img = document.createElement('img');
            img.src = `https://placehold.co/200x150/e0e0e0/333?text=Image`;
            img.className = 'w-full h-full object-cover pointer-events-none';
            img.onerror = () => { img.src = `https://placehold.co/200x150/e0e0e0/333?text=Error` };
            const caption = document.createElement('div');
            caption.className = 'image-caption';
            caption.textContent = 'Caption';
            caption.addEventListener('dblclick', (e) => { e.stopPropagation(); makeEditable(caption); });
            el.appendChild(img);
            el.appendChild(caption);
            setupElement(el, true);
            selectElement(el, false);
        });
        
        // --- SELECTION LOGIC ---
        function selectElement(el, shiftKeyPressed) {
            isCollisionViewActive = false;
            if (!shiftKeyPressed) { if (!(selectedElements.length === 1 && selectedElements[0] === el)) { selectedElements.forEach(selected => selected.classList.remove('selected')); selectedElements = []; } } const index = selectedElements.indexOf(el); if (index > -1) { if (shiftKeyPressed) { el.classList.remove('selected'); selectedElements.splice(index, 1); } } else { el.classList.add('selected'); selectedElements.push(el); } renderLayersPanel(); updatePropertiesPanel(); 
        }
        
        canvas.addEventListener('mousedown', (e) => { 
            if (e.target !== canvas) return; 
            isCollisionViewActive = false; 
            if (!e.shiftKey) { 
                selectedElements.forEach(el => el.classList.remove('selected')); 
                selectedElements = []; 
            } 
            const canvasRect = canvas.getBoundingClientRect();
            const startX = (e.clientX - canvasRect.left) / zoomLevel;
            const startY = (e.clientY - canvasRect.top) / zoomLevel;

            selectionBox.style.left = `${e.clientX - main.getBoundingClientRect().left}px`;
            selectionBox.style.top = `${e.clientY - main.getBoundingClientRect().top}px`;
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';

            function onMouseMove(e) {
                const currentX = (e.clientX - canvasRect.left) / zoomLevel;
                const currentY = (e.clientY - canvasRect.top) / zoomLevel;
                const newX = Math.min(startX, currentX);
                const newY = Math.min(startY, currentY);
                const newWidth = Math.abs(currentX - startX);
                const newHeight = Math.abs(currentY - startY);

                selectionBox.style.left = `${newX * zoomLevel + (canvasRect.left - main.getBoundingClientRect().left)}px`;
                selectionBox.style.top = `${newY * zoomLevel + (canvasRect.top - main.getBoundingClientRect().top)}px`;
                selectionBox.style.width = `${newWidth * zoomLevel}px`;
                selectionBox.style.height = `${newHeight * zoomLevel}px`;

                const boxRect = selectionBox.getBoundingClientRect();
                const allElements = [...canvas.children].filter(c => c.classList.contains('draggable'));
                allElements.forEach(el => {
                    const elRect = el.getBoundingClientRect();
                    if (boxRect.left < elRect.right && boxRect.right > elRect.left && boxRect.top < elRect.bottom && boxRect.bottom > elRect.top) {
                        if (!selectedElements.includes(el)) el.classList.add('selected');
                    } else {
                        if (!selectedElements.includes(el)) el.classList.remove('selected');
                    }
                });
            }
            function onMouseUp() {
                selectionBox.style.display = 'none';
                selectedElements = [...canvas.children].filter(c => c.classList.contains('selected'));
                renderLayersPanel();
                updatePropertiesPanel();
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        // --- KEYBOARD & PASTE LOGIC ---
        document.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.isContentEditable) {
                return;
            }
            
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const zoomInKey = isMac ? '=' : '+';

            if (e.key === zoomInKey) {
                e.preventDefault();
                setZoom(zoomLevel + 0.1);
            }
            if (e.key === '-') {
                e.preventDefault();
                setZoom(zoomLevel - 0.1);
            }

            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedElements.length > 0) {
                    selectedElements.forEach(el => el.remove());
                    selectedElements = [];
                    renderLayersPanel();
                    updatePropertiesPanel();
                }
            }
            
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'd') {
                e.preventDefault();
                if (selectedElements.length > 0) {
                    const newSelection = [];
                    selectedElements.forEach(el => {
                        const clone = el.cloneNode(true);
                        clone.id = `el-${elementCounter++}`;
                        clone.classList.remove('selected');
                        const oldResizer = clone.querySelector('.resizer');
                        if (oldResizer) oldResizer.remove();
                        clone.style.left = `${el.offsetLeft + 20}px`;
                        clone.style.top = `${el.offsetTop + 20}px`;
                        const isImage = clone.querySelector('img') !== null;
                        setupElement(clone, isImage);
                        canvas.appendChild(clone);
                        newSelection.push(clone);
                    });
                    selectedElements.forEach(el => el.classList.remove('selected'));
                    selectedElements = newSelection;
                    selectedElements.forEach(el => el.classList.add('selected'));
                    updateZIndexFromLayers();
                    updatePropertiesPanel();
                }
            }
        });
        
        document.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            let imageFile = null;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    imageFile = items[i].getAsFile();
                    break;
                }
            }
            if (imageFile) {
                e.preventDefault();
                const reader = new FileReader();
                reader.onload = function(event) {
                    const imageUrl = event.target.result;
                    const defaultWidth = 200;
                    const defaultHeight = 150;
                    const canvasRect = canvas.getBoundingClientRect();
                    const viewCenterX = (main.scrollLeft + canvasRect.width / 2) / zoomLevel;
                    const viewCenterY = (main.scrollTop + canvasRect.height / 2) / zoomLevel;

                    const el = createElement('div', 'p-0 overflow-hidden bg-gray-300 rounded-lg shadow-md relative', '', 'Image', {
                        width: `${defaultWidth}px`,
                        height: `${defaultHeight}px`,
                        left: `${viewCenterX - defaultWidth / 2}px`,
                        top: `${viewCenterY - defaultHeight / 2}px`
                    });
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.className = 'w-full h-full object-cover pointer-events-none';
                    const caption = document.createElement('div');
                    caption.className = 'image-caption';
                    caption.textContent = 'Caption';
                    caption.style.display = 'block';
                    caption.addEventListener('dblclick', (e) => { e.stopPropagation(); makeEditable(caption); });
                    el.appendChild(img);
                    el.appendChild(caption);
                    setupElement(el, true);
                    selectElement(el, false);
                };
                reader.readAsDataURL(imageFile);
            }
        });

        // --- ALIGN, DISTRIBUTE, GROUP LOGIC ---
        groupSelectionBtn.addEventListener('click', () => { if (selectedElements.length < 2) return; const padding = 20; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity, minZIndex = Infinity; selectedElements.forEach(el => { minX = Math.min(minX, el.offsetLeft); minY = Math.min(minY, el.offsetTop); maxX = Math.max(maxX, el.offsetLeft + el.offsetWidth); maxY = Math.max(maxY, el.offsetTop + el.offsetHeight); minZIndex = Math.min(minZIndex, parseInt(el.style.zIndex)); }); const boxStyles = { left: `${minX - padding}px`, top: `${minY - padding}px`, width: `${(maxX - minX) + padding * 2}px`, height: `${(maxY - minY) + padding * 2}px`, zIndex: minZIndex - 1 }; const groupBox = createElement('div', 'bg-white border-2 border-gray-400 rounded-lg', '', 'Box', boxStyles); groupBox.classList.add('selected'); selectedElements.push(groupBox); renderLayersPanel(); });
        alignVBtn.addEventListener('click', () => { if (selectedElements.length < 2) return; const totalCenterY = selectedElements.reduce((sum, el) => sum + (el.offsetTop + el.offsetHeight / 2), 0); const avgCenterY = totalCenterY / selectedElements.length; selectedElements.forEach(el => el.style.top = `${avgCenterY - (el.offsetHeight / 2)}px`); });
        alignHBtn.addEventListener('click', () => { if (selectedElements.length < 2) return; const totalCenterX = selectedElements.reduce((sum, el) => sum + (el.offsetLeft + el.offsetWidth / 2), 0); const avgCenterX = totalCenterX / selectedElements.length; selectedElements.forEach(el => el.style.left = `${avgCenterX - (el.offsetWidth / 2)}px`); });
        distributeHBtn.addEventListener('click', () => { if (selectedElements.length < 3) return; const sorted = [...selectedElements].sort((a, b) => a.offsetLeft - b.offsetLeft); const leftMost = sorted[0]; const rightMost = sorted[sorted.length - 1]; const totalWidth = sorted.reduce((sum, el) => sum + el.offsetWidth, 0); const totalSpace = rightMost.offsetLeft + rightMost.offsetWidth - leftMost.offsetLeft; const gap = (totalSpace - totalWidth) / (sorted.length - 1); let currentLeft = leftMost.offsetLeft + leftMost.offsetWidth + gap; for (let i = 1; i < sorted.length - 1; i++) { sorted[i].style.left = `${currentLeft}px`; currentLeft += sorted[i].offsetWidth + gap; } });
        distributeVBtn.addEventListener('click', () => { if (selectedElements.length < 3) return; const sorted = [...selectedElements].sort((a, b) => a.offsetTop - b.offsetTop); const topMost = sorted[0]; const bottomMost = sorted[sorted.length - 1]; const totalHeight = sorted.reduce((sum, el) => sum + el.offsetHeight, 0); const totalSpace = bottomMost.offsetTop + bottomMost.offsetHeight - topMost.offsetTop; const gap = (totalSpace - totalHeight) / (sorted.length - 1); let currentTop = topMost.offsetTop + topMost.offsetHeight + gap; for (let i = 1; i < sorted.length - 1; i++) { sorted[i].style.top = `${currentTop}px`; currentTop += sorted[i].offsetHeight + gap; } });
        
        detectCollisionsBtn.addEventListener('click', () => {
            isCollisionViewActive = selectedElements.length === 1;
            renderLayersPanel();
        });

        // --- DRAG LOGIC ---
        function makeDraggable(element) {
            element.addEventListener('mousedown', dragMouseDown);
            function dragMouseDown(e) {
                if (e.target.classList.contains('resizer') || e.target.isContentEditable) return;
                e.preventDefault(); e.stopPropagation();
                selectElement(element, e.shiftKey);
                const canvasRect = canvas.getBoundingClientRect();
                const initialMouseCanvasX = (e.clientX - canvasRect.left) / zoomLevel;
                const initialMouseCanvasY = (e.clientY - canvasRect.top) / zoomLevel;
                const initialPositions = selectedElements.map(el => ({ el: el, initialLeft: el.offsetLeft, initialTop: el.offsetTop }));

                function elementDrag(e) {
                    e.preventDefault();
                    const currentMouseCanvasX = (e.clientX - canvasRect.left) / zoomLevel;
                    const currentMouseCanvasY = (e.clientY - canvasRect.top) / zoomLevel;
                    const deltaX = currentMouseCanvasX - initialMouseCanvasX;
                    const deltaY = currentMouseCanvasY - initialMouseCanvasY;
                    
                    let newLeft = initialPositions[0].initialLeft + deltaX;
                    let newTop = initialPositions[0].initialTop + deltaY;

                    if (selectedElements.length === 1) {
                        const snapThreshold = 6;
                        snapLineV.style.display = 'none'; snapLineH.style.display = 'none';
                        const otherElements = [...canvas.children].filter(child => child !== element && child.classList.contains('draggable'));
                        let closestSnap = { v: null, h: null, distV: snapThreshold, distH: snapThreshold };
                        for (const otherEl of otherElements) {
                            const current = { left: newLeft, right: newLeft + element.offsetWidth, hCenter: newLeft + element.offsetWidth / 2, top: newTop, bottom: newTop + element.offsetHeight, vCenter: newTop + element.offsetHeight / 2 };
                            const other = { left: otherEl.offsetLeft, right: otherEl.offsetLeft + otherEl.offsetWidth, hCenter: otherEl.offsetLeft + otherEl.offsetWidth / 2, top: otherEl.offsetTop, bottom: otherEl.offsetTop + otherEl.offsetHeight, vCenter: otherEl.offsetTop + otherEl.offsetHeight / 2 };
                            const vPoints = ['left', 'hCenter', 'right'];
                            vPoints.forEach(p1 => vPoints.forEach(p2 => { const dist = Math.abs(current[p1] - other[p2]); if (dist < closestSnap.distV) { closestSnap.distV = dist; closestSnap.v = { snapLinePos: other[p2], newElementPos: newLeft - (current[p1] - other[p2]) }; } }));
                            const hPoints = ['top', 'vCenter', 'bottom'];
                            hPoints.forEach(p1 => hPoints.forEach(p2 => { const dist = Math.abs(current[p1] - other[p2]); if (dist < closestSnap.distH) { closestSnap.distH = dist; closestSnap.h = { snapLinePos: other[p2], newElementPos: newTop - (current[p1] - other[p2]) }; } }));
                        }
                        if (closestSnap.v) { newLeft = closestSnap.v.newElementPos; snapLineV.style.left = `${(closestSnap.v.snapLinePos * zoomLevel) + canvasRect.left - main.getBoundingClientRect().left}px`; snapLineV.style.display = 'block'; }
                        if (closestSnap.h) { newTop = closestSnap.h.newElementPos; snapLineH.style.top = `${(closestSnap.h.snapLinePos * zoomLevel) + canvasRect.top - main.getBoundingClientRect().top}px`; snapLineH.style.display = 'block'; }
                    }

                    initialPositions.forEach((pos, index) => {
                        const currentDeltaX = newLeft - pos.initialLeft;
                        const currentDeltaY = newTop - pos.initialTop;
                        if(index === 0) {
                            pos.el.style.left = `${newLeft}px`;
                            pos.el.style.top = `${newTop}px`;
                        } else {
                             pos.el.style.left = `${pos.initialLeft + deltaX}px`;
                             pos.el.style.top = `${pos.initialTop + deltaY}px`;
                        }
                    });
                }
                function closeDragElement() {
                    snapLineV.style.display = 'none'; snapLineH.style.display = 'none';
                    document.removeEventListener('mousemove', elementDrag);
                    document.removeEventListener('mouseup', closeDragElement);
                }
                document.addEventListener('mousemove', elementDrag);
                document.addEventListener('mouseup', closeDragElement);
            }
        }

        // --- MISC LOGIC ---
        function setupElement(el, isImageContainer = false) { 
            const resizer = document.createElement('div'); 
            resizer.className = 'resizer'; 
            el.appendChild(resizer); 
            makeDraggable(el); 
            makeResizable(el, resizer, isImageContainer); 
            if (!isImageContainer && el.dataset.type !== 'Imagen') { 
                el.addEventListener('dblclick', (e) => { e.stopPropagation(); makeEditable(el); }); 
            } 
        }
        function makeEditable(el) { el.contentEditable = true; el.focus(); document.execCommand('selectAll', false, null); const onBlur = () => { el.contentEditable = false; renderLayersPanel(); el.removeEventListener('blur', onBlur); el.removeEventListener('keydown', onKeydown); }; const onKeydown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); el.blur(); } else if (e.key === 'Escape') { document.execCommand('undo'); el.blur(); } }; el.addEventListener('blur', onBlur); el.addEventListener('keydown', onKeydown); }
        function makeResizable(element, resizer, isImageContainer = false) { let original_w = 0, original_h = 0, original_x = 0, original_y = 0; resizer.addEventListener('mousedown', function(e) { e.preventDefault(); e.stopPropagation(); original_w = parseFloat(getComputedStyle(element, null).getPropertyValue('width').replace('px', '')); original_h = parseFloat(getComputedStyle(element, null).getPropertyValue('height').replace('px', '')); original_x = e.pageX; original_y = e.pageY; window.addEventListener('mousemove', resize); window.addEventListener('mouseup', stopResize); }); function resize(e) { const dx = (e.pageX - original_x) / zoomLevel; const dy = (e.pageY - original_y) / zoomLevel; const width = original_w + dx; const height = original_h + dy; if (width > 30) element.style.width = width + 'px'; if (height > 30) element.style.height = height + 'px'; if (isImageContainer) { const img = element.querySelector('img'); if (img && !img.src.startsWith('data:')) { const newWidth = Math.round(width); const newHeight = Math.round(height); img.src = `https://placehold.co/${newWidth}x${newHeight}/e0e0e0/333?text=Image`; } } } function stopResize() { window.removeEventListener('mousemove', resize); window.removeEventListener('mouseup', stopResize); } }
        
        // --- SAVE & LOAD ---
        const LOCAL_STORAGE_KEY = 'visualDesignerCanvasState';
        saveCanvasBtn.addEventListener('click', saveCanvasState);
        clearCanvasBtn.addEventListener('click', () => { const modal = document.createElement('div'); modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'; modal.innerHTML = ` <div class="bg-white rounded-lg p-8 shadow-2xl"> <h3 class="text-lg font-bold mb-4">Confirm Action</h3> <p>Are you sure? All work and the current save will be lost.</p> <div class="mt-6 flex justify-end space-x-4"> <button id="confirm-clear" class="bg-red-500 text-white px-4 py-2 rounded-lg">Yes, clear</button> <button id="cancel-clear" class="bg-gray-300 px-4 py-2 rounded-lg">Cancel</button> </div> </div> `; document.body.appendChild(modal); document.getElementById('confirm-clear').onclick = () => { canvas.innerHTML = ''; localStorage.removeItem(LOCAL_STORAGE_KEY); selectedElements = []; isCollisionViewActive = false; renderLayersPanel(); updatePropertiesPanel(); document.body.removeChild(modal); }; document.getElementById('cancel-clear').onclick = () => document.body.removeChild(modal); });

        function saveCanvasState() {
            const elements = [...canvas.children].filter(c => c.classList.contains('draggable'));
            const state = {
                elements: elements.map(el => ({
                    tag: el.tagName,
                    className: el.className,
                    style: el.getAttribute('style'),
                    innerHTML: el.innerHTML,
                    dataset: { ...el.dataset }
                })),
                counter: elementCounter
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));
            saveCanvasBtn.textContent = 'Saved!';
            saveCanvasBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            saveCanvasBtn.classList.add('bg-green-500');
            setTimeout(() => {
                saveCanvasBtn.textContent = 'Save Progress';
                saveCanvasBtn.classList.remove('bg-green-500');
                saveCanvasBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            }, 1500);
        }

        function loadCanvasState() {
            const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (!savedState) return;
            
            const state = JSON.parse(savedState);
            canvas.innerHTML = '';
            elementCounter = state.counter || 0;

            state.elements.forEach(elData => {
                const el = document.createElement(elData.tag);
                el.className = elData.className;
                el.setAttribute('style', elData.style);
                el.innerHTML = elData.innerHTML;
                Object.assign(el.dataset, elData.dataset);
                el.id = `el-${elementCounter++}`;
                
                const isImageContainer = el.querySelector('img') !== null;
                setupElement(el, isImageContainer);
                if (isImageContainer) {
                    const caption = el.querySelector('.image-caption');
                    if (caption) {
                        caption.addEventListener('dblclick', (e) => { e.stopPropagation(); makeEditable(caption); });
                    }
                }
                canvas.appendChild(el);
            });
            renderLayersPanel();
        }
        
        // --- SCREENS LOGIC ---
        addScreenBtn.addEventListener('click', () => {
            const selectedOption = screenPresetSelect.options[screenPresetSelect.selectedIndex];
            const [width, height] = selectedOption.value.split('x');
            const screenName = selectedOption.text;

            if (!width || !height) return;

            createElement('div', 'bg-white border-2 border-gray-400 rounded-lg screen-box', '', 'Pantalla', 
                { width: `${width}px`, height: `${height}px` },
                { name: screenName, screenName: screenName }
            );
        });
        
        // Load state on startup and render initial layers panel
        document.addEventListener('DOMContentLoaded', () => {
            loadCanvasState();
            renderLayersPanel();
        });
    </script>
</body>
</html>
